<!DOCTYPE html>

<html>

<head>

    <script src="https://cdn.jsdelivr.net/npm/phaser@3.55.2/dist/phaser.js"></script>

</head>

<body>

    <script>

        var config = {
            type: Phaser.AUTO,
            width: 1200,
            height: 700,
            physics: {
                default: 'arcade',
                arcade: {
                    // debug: true,
                    debugShowVelocity: true,
                }
            },

            scene: {
                preload: preload,
                create: create,
                update: update,
            }

            //BIG BALLING
            //BigBalling2
        };

        class ProjectileGroup extends Phaser.Physics.Arcade.Group {
            constructor(scene) {
                super(scene.physics.world, scene);

                // Initialize the group
                this.createMultiple({
                    classType: Projectile, // This is the class we create just below
                    frameQuantity: 200, // Create 200 instances in the pool
                    active: false,
                    visible: false,
                    key: 'projectile'
                })
            }

            fire(x, y, direction, speed) {
                // Get the first available sprite in the group
                const newProjectile = this.getFirstDead(false);
                if (newProjectile) {
                    newProjectile.fire(x, y, direction, speed);
                }
            }
        }

        class Projectile extends Phaser.Physics.Arcade.Sprite {
            projectileType;

            _distanceTraveled = 0;
            _previousPosition;
            _secondsPassed = 0;
            _pierceCount = 0;
            _piercedObjects = [];

            UUID;

            maxDistance = 1000;
            maxPierce = 1;

            constructor(scene, x, y, projectileType, config) {
                super(scene, x, y, projectileType);
                this.projectileId = projectileType;
                this._previousPosition = { x: x, y: y };
                this._distanceTraveled = 0;
                this._secondsPassed = 0;
                this.setScale(.1, .1);
            }

            _testAlive() {
                if (this.y <= 0 || this.y >= config.height || this.x <= 0 || this.x >= config.width) { return false }
                if (this.maxDistance <= this._distanceTraveled) { return false };
                if (this._pierceCount > this.maxPierce) { return false };
                return true
            }

            preUpdate(time, delta) { // before the game updates physics
                super.preUpdate(time, delta);

                this._timePassed += delta;
                this._distanceTraveled += Phaser.Math.Distance.Between(this._previousPosition.x, this._previousPosition.y, this.x, this.y);

                this._previousPosition = { x: this.x, y: this.y }

                if (!this._testAlive()) {
                    this.disableBody(true, true);
                }
            }

            fire(x, y, direction, speed = 100) {
                direction.normalize()

                this.enableBody(true, x, y, true, true);
                this._previousPosition = { x: x, y: y } //reset previous position for distance calculation

                this._distanceTraveled = 0;
                this._secondsPassed = 0;
                this._pierceCount = 0;

                this.setActive(true);
                this.setVisible(true);

                this.setVelocity((speed) * direction.x, (speed) * direction.y) // default speed is 100
            }

            onHit(hitObject) {
                if (this._piercedObjects.find(element => element == hitObject.UUID)) { console.log("alreadyhit"); return }
                this._pierceCount += 1;
                this._piercedObjects.push(hitObject.UUID);
            }
        }

        class Player extends Phaser.Physics.Arcade.Sprite {
            _iframeremainingtime = 0;
            _timesincelastshot = 0;

            iframeTime = .25; //seconds

            shootTimer;
            shooting = false
            shotDebounce = false

            myscene;
            myprojectilegroup;

            accelerationFactor = 500
            turnAcceleration = 1000
            turnRate = 145
            movementSpeed = 500
            maxMovementSpeed = 500

            health = 100
            shotAmount = 1
            shotSpread = 5
            fireRate = 600 // rounds per minute
            shotSpeed = 1000
            shotDamage = 10;

            UUID = ([1e7] + -1e3 + -4e3 + -8e3 + -1e11).replace(/[018]/g, c => (c ^ crypto.getRandomValues(new Uint8Array(1))[0] & 15 >> c / 4).toString(16));

            constructor(projectileGroup, scene, x, y) {
                super(scene, x, y, 'player');
                scene.add.existing(this);
                scene.physics.add.existing(this);
                this.setCollideWorldBounds(true);

                this.setDamping(true)
                this.setDrag(.25, .25)
                this.setAngularDrag(100)
                this.setBounce(.5, .5)
                this.myscene = scene;
                this.myprojectilegroup = projectileGroup
            }

            shoot() {
                let playerLookVector = new Phaser.Math.Vector2(Math.cos(this.rotation), Math.sin(this.rotation))
                for (let i = 0; i < this.shotAmount; i++) {
                    let dividend = ~~(this.shotAmount / 2)
                    let bulletLookVector = playerLookVector.clone()

                    bulletLookVector.rotate((this.shotSpread * Math.PI / 180) * (i - dividend))
                    this.myprojectilegroup.fire(this.x, this.y, bulletLookVector, this.shotSpeed)
                }
            }

            isAlive() {
                if (this.health <= 0) { return false }
                return true
            }

            updatePlayerMovement() {
                this.setAcceleration(0, 0)
                this.setAngularAcceleration(0)

                let playerMouseDelta = new Phaser.Math.Vector2(this.myscene.input.mousePointer.x - this.x, this.myscene.input.mousePointer.y - this.y)
                let playerLookVector = new Phaser.Math.Vector2(Math.cos(this.rotation), Math.sin(this.rotation))

                this.setRotation(Math.atan2(playerMouseDelta.y, playerMouseDelta.x))

                let movementVector = new Phaser.Math.Vector2(0, 0)

                if (keys.W.isDown) { movementVector.add(new Phaser.Math.Vector2(0, -1)) }
                if (keys.A.isDown) { movementVector.add(new Phaser.Math.Vector2(-1, 0)) }
                if (keys.S.isDown) { movementVector.add(new Phaser.Math.Vector2(0, 1)) }
                if (keys.D.isDown) { movementVector.add(new Phaser.Math.Vector2(1, 0)) }

                movementVector.normalize()

                this.setAcceleration(this.movementSpeed * movementVector.x, this.movementSpeed * movementVector.y)
            }

            preUpdate(time, deltaTime) {
                super.preUpdate(time, deltaTime)

                if (!this.isAlive()) {
                    this.destroy()
                    return
                }

                if (this._iframeremainingtime > 0) {
                    this._iframeremainingtime = Math.max(0, this._iframeremainingtime - deltaTime);
                }

                this._timesincelastshot += deltaTime
                if (this._timesincelastshot >= (1 / (this.fireRate / 60) * 1000) && this.myscene.input.mousePointer.isDown) {
                    this._timesincelastshot = 0;
                    this.shoot()
                }

                this.updatePlayerMovement()
            }

            takeDamage(damage) {
                if (this._iframeremainingtime > 0) {
                    return;
                }
                this._iframeremainingtime = this.iframeTime * 1000;
                this.health -= damage;
            }
        }

        // Enemey that runs around and always faces the player
        class SwarmEnemy extends Phaser.Physics.Arcade.Sprite {
            _timesincelastmove = 0;
            _scene;

            target;
            health = 150;
            moveDelay = 1; //seconds
            attackDamage = 5;
            alive = true;

            UUID = ([1e7] + -1e3 + -4e3 + -8e3 + -1e11).replace(/[018]/g, c => (c ^ crypto.getRandomValues(new Uint8Array(1))[0] & 15 >> c / 4).toString(16));

            constructor(scene, x, y, projectileGroup) {
                super(scene, x, y, 'SwarmEnemy');
                scene.add.existing(this);
                scene.physics.add.existing(this);
                this._scene = scene;
                this.setGravityY(0);
                this.setScale(.5);
                this.move(this);
                this.target = player;
                this.setMaxVelocity(500, 500);
            }

            setTarget(target) {
                this.target = target
            }

            isAlive() {
                if (this.health <= 0) { return false }
                return true
            }

            kill() {
                this.destroy();
                this.alive = false;
                console.log("Died")
            }

            reflectPosition() {
                if (this.x >= config.width + this.width) {
                    this.x = 1
                } else if (this.x <= 0 - this.width) {
                    this.x = config.width - 1;
                }

                if (this.y >= config.height + this.height) {
                    this.y = 1
                } else if (this.y <= 0 - this.height) {
                    this.y = config.height - 1;
                }
            }

            //moves the enemy to a random targeted location
            move() {
                let newspotx = Phaser.Math.Between(1, 1200);
                let newspoty = Phaser.Math.Between(1, 700);
                this.setAccelerationX((newspotx - this.x) / 3);
                this.setAccelerationY((newspoty - this.y) / 3);
            }

            preUpdate(time, deltaTime) {
                super.preUpdate(time, deltaTime)
                if (!this.isAlive()) { this.kill(); return; }

                this.rotation = Math.atan2(this.target.y - this.y, this.target.x - this.x);

                this._timesincelastmove += deltaTime;
                if (this._timesincelastmove >= this.moveDelay * 1000) {
                    this.move();
                    this._timesincelastmove = 0;
                }

                this.reflectPosition();
            }

            takeDamage(damage) {
                this.health -= damage;
            }
        }

        var game = new Phaser.Game(config);
        var player;

        var playerProjectileGroup;
        var enemyProjectileGroup;

        //Keyboard controls
        var cursors;
        var keys;
        var space;

        var enemies = [];

        function preload() {
            this.load.image('stars', 'assets/newstarbackground.png');
            this.load.image('player', 'assets/maincharacter.png');
            this.load.image('SwarmEnemy', 'assets/Enemy_1.png');
        }

        // initializes a single Runner Enemy
        function createSwarmEnemy(tempScene) {
            let myEnemy = new SwarmEnemy(tempScene, 100, 100);
            myEnemy.target = player;
            enemies.push(myEnemy);
        }

        //moves all sprites in enemies[]
        function create() {
            let background = this.add.tileSprite(0, 0, game.scale.width, game.scale.height, 'stars').setOrigin(0, 0);
            playerProjectileGroup = new ProjectileGroup(this);
            enemyProjectileGroup = new ProjectileGroup(this);

            player = new Player(playerProjectileGroup, this, 500, 500);

            for (let i = 1; i < 2; i++) {
                createSwarmEnemy(this)
            }

            //Set up user input
            cursors = this.input.keyboard.createCursorKeys();
            keys = this.input.keyboard.addKeys('W, A, S, D');
        }

        function update(time, delta) {
            let deltaSeconds = delta / 1000
            let timeSeconds = time / 1000

            this.physics.overlap(player, enemies, function (player, targetEnemy) { player.takeDamage(targetEnemy.attackDamage); });
            this.physics.overlap(enemies, playerProjectileGroup, function (enemy, playerProjectile) { enemy.takeDamage(player.shotDamage); playerProjectile.onHit(enemy); })
            this.physics.overlap(player, enemyProjectileGroup, function (player, enemyProjectile) { player.takeDamage(player.shotDamage); enemyProjectile.onHit(player); })
        }
    </script>

</body>

</html>