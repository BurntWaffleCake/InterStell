<!DOCTYPE html>

<html>

<head>

    <script src="https://cdn.jsdelivr.net/npm/phaser@3.55.2/dist/phaser.js"></script>

</head>

<body>

    <script>

        var config = {
            type: Phaser.AUTO,
            width: 1200,
            height: 700,
            physics: {
                default: 'arcade',
                arcade: {
                    debug: true,
                    debugShowVelocity: true,
                }
            },

            scene: {
                preload: preload,
                create: create,
                update: update,
            }

            //BIG BALLING
            //BigBalling2
        };

        class PlayerProjectileGroup extends Phaser.Physics.Arcade.Group {
            constructor(scene) {
                super(scene.physics.world, scene);

                // Initialize the group
                this.createMultiple({
                    classType: Projectile, // This is the class we create just below
                    frameQuantity: 200, // Create 200 instances in the pool
                    active: false,
                    visible: false,
                    key: 'projectile'
                })
            }

            fire(x, y, direction, speed) {
                // Get the first available sprite in the group
                const newProjectile = this.getFirstDead(false);
                if (newProjectile) {
                    newProjectile.fire(x, y, direction, speed);
                }
            }
        }

        class Projectile extends Phaser.Physics.Arcade.Sprite {
            projectileType;
            
            _distanceTraveled = 0;
            _previousPosition;
            _secondsPassed = 0;
            _pierceCount = 0;

            maxDistance = 250;
            maxPierce = 0;

            constructor(scene, x, y, projectileType, config) { 
                super(scene, x, y, projectileType);
                this.projectileId = projectileType;
                this._previousPosition = { x: x, y: y };
                this._distanceTraveled = 0;
                this._secondsPassed = 0;
                this.setScale(.1, .1);
                this.addListener("overlap", function() { console.log("Projectile overlaped") })
            }

            _testAlive() {
                if (this.y <= 0 || this.y >= config.height || this.x <= 0 || this.x >= config.width) { return false }
                if (this.maxDistance <= this._distanceTraveled) { return false };
                if (this._pierceCount > this.maxPierce) { return false };
                return true
            }

            preUpdate(time, delta) { // before the game updates physics
                super.preUpdate(time, delta);

                this._timePassed += delta;
                this._distanceTraveled += Phaser.Math.Distance.Between(this._previousPosition.x, this._previousPosition.y, this.x, this.y);

                this._previousPosition = { x: this.x, y: this.y }

                console.log(this._testAlive())

                if (!this._testAlive()) {
                    this.disableBody(true, true);
                    console.log("Projectile Killed")
                }
            }

            fire(x, y, direction, speed = 100) {
                direction.normalize()

                this.enableBody(true, x, y, true, true);
                this._previousPosition = { x: x, y: y } //reset previous position for distance calculation

                this._distanceTraveled = 0;
                this._secondsPassed = 0;

                this.setActive(true);
                this.setVisible(true);

                this.setVelocity((speed) * direction.x, (speed) * direction.y) // default speed is 100
            }

            onHit() {
                this._pierceCount -= 1;
            }
        }

        class Player extends Phaser.Physics.Arcade.Sprite {
                shootTimer;
                shooting = false
                shotDebounce = false

                myscene;

                accelerationFactor = 500
                turnAcceleration = 1000
                turnRate = 145
                movementSpeed = 500
                maxMovementSpeed = 500

                health = 100
                shotAmount = 1
                shotSpread = 5
                fireRate = 600 // rounds per minute
                shotSpeed = 1000
                shotDamage = 100;

                constructor(scene, x, y) {
                    super(scene, x, y, 'player');
                    scene.add.existing(this);
                    scene.physics.add.existing(this);
                    this.setCollideWorldBounds(true);

                    this.setDamping(true)
                    this.setDrag(.25, .25)
                    this.setAngularDrag(100)
                    this.setBounce(.5, .5)
                    this.myscene = scene;
                }

                isAlive() {
                    if (this.health <= 0 ) { return false }
                    return true
                }

                updatePlayerMovement() {
                    this.setAcceleration(0, 0)
                    this.setAngularAcceleration(0)

                    let playerMouseDelta = new Phaser.Math.Vector2(this.myscene.input.mousePointer.x - this.x, this.myscene.input.mousePointer.y - this.y)
                    let playerLookVector = new Phaser.Math.Vector2(Math.cos(this.rotation), Math.sin(this.rotation))

                    this.setRotation(Math.atan2(playerMouseDelta.y, playerMouseDelta.x))

                    let movementVector = new Phaser.Math.Vector2(0, 0)

                    if (keys.W.isDown) { movementVector.add(new Phaser.Math.Vector2(0, -1)) }
                    if (keys.A.isDown) { movementVector.add(new Phaser.Math.Vector2(-1, 0)) }
                    if (keys.S.isDown) { movementVector.add(new Phaser.Math.Vector2(0, 1)) }
                    if (keys.D.isDown) { movementVector.add(new Phaser.Math.Vector2(1, 0)) }

                    movementVector.normalize()

                    this.setAcceleration(this.movementSpeed * movementVector.x, this.movementSpeed * movementVector.y)
                }

                preUpdate() {
                    if (!this.isAlive()) {
                        this.destroy()
                        return
                    }
                    this.updatePlayerMovement()
                }

                takeDamage(damage) {
                    this.health -= damage;
                }
            }

        // Enemey that runs around and always faces the player
        class SwarmEnemy extends Phaser.Physics.Arcade.Sprite {
            health = 100;
            attackDamage = 5;
            _scene;
            alive = true;

            constructor(scene, x, y, projectileGroup) {
                super(scene, x, y, 'SwarmEnemy');
                scene.add.existing(this);
                scene.physics.add.existing(this);
                this._scene = scene;
                this.setCollideWorldBounds(true);
                this.setGravityY(0);
                this.setScale(.5);
                this.move(this) 
            }

            isAlive() {
                if (this.health <= 0 ) { return false }
                return true
            }

            kill() {
                this.destroy();
                this.alive = false;
            }

            //moves the enemy to a random targeted location
            move() {
                if (!this.alive) { return }
                // guiTimer = this.time.delayedCall(1000, this.moveRight(), [], this); // delayed remove text call
                // guiTimer1 = this.time.delayedCall(1000, this.moveLeft(), [], this); // delayed remove text call
                let newspotx = Phaser.Math.Between(1, 1200);
                let newspoty = Phaser.Math.Between(1, 700);
                this.setAccelerationX((newspotx - this.x) / 3);
                this.setAccelerationY((newspoty - this.y) / 3);
                setTimeout( function() { moveSwarmEnemies(); }, 0);
            }

            preUpdate() {
                console.log("Updating enemy", this.health);
                if (!this.isAlive()) { this.kill(); return; }
            }

            takeDamage(damage) {
                console.log(this.health, damage)
                this.health -= damage;
            }
        }

        var game = new Phaser.Game(config);
        var player;

        var playerProjectileGroup;

        //Keyboard controls
        var cursors;
        var keys;
        var space;

        var enemies = [];

        function preload() {
            this.load.image('stars', 'assets/newstarbackground.png');
            this.load.image('player', 'assets/maincharacter.png');
            this.load.image('SwarmEnemy', 'assets/Enemy_1.png');
        }

        // initializes a single Swarm Enemy
        function createSwarmEnemy(tempScene) {
            let myEnemy = new SwarmEnemy(tempScene, 100, 100);
            enemies.push(myEnemy);
        }

        //moves all sprites in enemies[]
        function moveSwarmEnemies() {
            for (let i = 0; i < enemies.length; i++) {
                enemies[i].move();
                enemies[i].rotation = Math.atan2(player.y - enemies[i].y, player.x - enemies[i].x);
            }

        }

        function create() {
            let background = this.add.tileSprite(0, 0, game.scale.width, game.scale.height, 'stars').setOrigin(0, 0);
            playerProjectileGroup = new PlayerProjectileGroup(this);
            this.input.on('pointerdown', onMouse1Down)
            this.input.on('pointerup', onMouse1Up)

            player = new Player(this, 400, 400);

            createSwarmEnemy(this)

            //Set up user input
            cursors = this.input.keyboard.createCursorKeys();
            keys = this.input.keyboard.addKeys('W, A, S, D');

        }

        function onMouse1Up() {
            player.shooting = false;
            if (!player.shotDebounce) {
                player.shotDebounce = true;
                player.myscene.time.delayedCall(
                    1 / (player.fireRate / 60) * 1000,                // ms
                    function () { player.shotDebounce = false },
                    [],
                    this
                );
            }
        }

        function shootPlayerBullet() {
            let playerLookVector = new Phaser.Math.Vector2(Math.cos(player.rotation), Math.sin(player.rotation))
            for (let i = 0; i < player.shotAmount; i++) {
                let dividend = ~~(player.shotAmount / 2)
                let bulletLookVector = playerLookVector.clone()

                bulletLookVector.rotate((player.shotSpread * Math.PI / 180) * (i - dividend))
                playerProjectileGroup.fire(player.x, player.y, bulletLookVector, player.shotSpeed)
            }

            if (player.shooting) {
                player.shootTimer = this.time.delayedCall(
                    1 / (player.fireRate / 60) * 1000,                // ms
                    shootPlayerBullet,
                    [],
                    this
                );
            }
        }

        function onMouse1Down() {
            player.shooting = true
            player.shootTimer = player.myscene.time.delayedCall(
                1 / (player.fireRate / 60) * 1000,                // ms
                shootPlayerBullet,
                [],
                player.myscene
            );

        }

        function update(time, delta) {
            let deltaSeconds = delta / 1000
            let timeSeconds = time / 1000

            this.physics.overlap(player, enemies, function(player, targetEnemy) {  console.log(player, targetEnemy); player.takeDamage(targetEnemy.attackDamage); });
            this.physics.overlap(enemies, playerProjectileGroup, function(enemy, playerProjectile) { enemy.takeDamage(player.shotDamage); playerProjectile.onHit(); } )
        }

    </script>

</body>

</html>
