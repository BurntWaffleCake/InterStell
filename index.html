<!DOCTYPE html>

<html>

<head>

    <script src="https://cdn.jsdelivr.net/npm/phaser@3.55.2/dist/phaser.js"></script>

</head>

<body>

    <script>

        var config = {
            mode: Phaser.Scale.CENTER_BOTH, 
            type: Phaser.AUTO,
            width: 1200,
            height: 700,
            physics: {
                default: 'arcade',
                arcade: {
                    debug: false,
                    debugShowVelocity: true,
                }
            },

            scene: {
                preload: preload,
                create: create,
                update: update,
            }

            //BIG BALLING
            //BigBalling2
        };

        class ProjectileGroup extends Phaser.Physics.Arcade.Group {
            constructor(scene, spriteName) {
                super(scene.physics.world, scene);

                // Initialize the group
                this.createMultiple({
                    classType: Projectile, // This is the class we create just below
                    frameQuantity: 200, // Create 200 instances in the pool
                    active: false,
                    visible: false,
                    key: spriteName
                })
            }

            fire(x, y, direction, config) {
                // Get the first available sprite in the group
                const newProjectile = this.getFirstDead(false);
                if (newProjectile) {
                    newProjectile.fire(x, y, direction, config);
                }
            }
        }

        class Projectile extends Phaser.Physics.Arcade.Sprite {
            projectileType;

            _distanceTraveled = 0;
            _previousPosition;
            _secondsPassed = 0;
            _pierceCount = 0;
            _piercedObjects = [];

            UUID;

            maxDistance = 1000;
            maxPierce = 0;
            damage = 10;

            constructor(scene, x, y, spriteName) {
                super(scene, x, y, spriteName);

                this._previousPosition = { x: x, y: y } //reset previous position for distance calculation
                this._distanceTraveled = 0;
                this._secondsPassed = 0;
                this._pierceCount = 0;
            }

            resetValues(x, y) {
                this._previousPosition = { x: x, y: y } //reset previous position for distance calculation
                this._distanceTraveled = 0;
                this._secondsPassed = 0;
                this._pierceCount = 0;
                this._piercedObjects = []
            }

            _testAlive() {
                if (this.y <= 0 || this.y >= config.height || this.x <= 0 || this.x >= config.width) { return false }
                if (this.maxDistance <= this._distanceTraveled) { return false };
                if (this._pierceCount > this.maxPierce) { return false };
                return true
            }

            preUpdate(time, delta) { // before the game updates physics
                super.preUpdate(time, delta);

                if (!this._testAlive()) {
                    this.disableBody(true, true);
                }

                this._timePassed += delta;
                this._distanceTraveled += Phaser.Math.Distance.Between(this._previousPosition.x, this._previousPosition.y, this.x, this.y);

                this._previousPosition = { x: this.x, y: this.y }
                this.rotation = Math.atan2(this.body.velocity.y / this.body.velocity.length(), this.body.velocity.x / this.body.velocity.length());
            }

            fire(x, y, direction, config) {
                this.resetValues(x, y);

                this.enableBody(true, x, y, true, true);
                this.setActive(true);
                this.setVisible(true);

                this.setBodySize(config.width || 10, config.height || 10, true);
                this.setDisplaySize(config.width || 10, config.height || 10)
                this.maxDistance = config.maxDistance;
                this.maxPierce = config.maxPierce;
                this.damage = config.damage;

                direction.normalize();
                this.setVelocity((config.speed) * direction.x, (config.speed) * direction.y) // default speed is 100
            }

            onHit(hitObject) {
                if (this._piercedObjects.find(element => element == hitObject.UUID)) { console.log("alreadyhit"); return }
                this._pierceCount += 1;
                this._piercedObjects.push(hitObject.UUID);
            }
        }

        class Player extends Phaser.Physics.Arcade.Sprite {
            _iframeremainingtime = 0;
            _timesincelastshot = 0;

            iframeTime = .25; //seconds

            shootTimer;
            shooting = false
            shotDebounce = false

            myscene;
            myprojectilegroup;

            accelerationFactor = 1000
            turnAcceleration = 1000
            turnRate = 145
            movementSpeed = 1000
            maxMovementSpeed = 250

            health = 100

            shotAmount = 1
            shotSpread = 5
            fireRate = 600 // rounds per minute

            shotSpeed = 1000
            shotDamage = 10;
            shotPierce = 0;
            shotDistance = 1000;

            UUID = ([1e7] + -1e3 + -4e3 + -8e3 + -1e11).replace(/[018]/g, c => (c ^ crypto.getRandomValues(new Uint8Array(1))[0] & 15 >> c / 4).toString(16));

            constructor(scene, x, y, projectileGroup) {
                super(scene, x, y, 'player');
                scene.add.existing(this);
                scene.physics.add.existing(this);
                this.setCollideWorldBounds(true);

                this.setDamping(true)
                this.setDrag(.25, .25)
                this.setAngularDrag(100)
                this.setBounce(.5, .5)
                this.setMaxVelocity(this.maxMovementSpeed, this.maxMovementSpeed)
                this.myscene = scene;
                this.myprojectilegroup = projectileGroup
            }

            shoot() {
                let playerLookVector = new Phaser.Math.Vector2(Math.cos(this.rotation), Math.sin(this.rotation))
                
                for (let i = 0; i < this.shotAmount; i++) {
                    let dividend = ~~(this.shotAmount / 2)
                    let bulletLookVector = playerLookVector.clone()
                    let evenAddition = (this.shotAmount % 2 == 0) ? (this.shotSpread / 2 * Math.PI / 180) : 0

                    bulletLookVector.rotate((this.shotSpread * Math.PI / 180) * (i - dividend) + evenAddition)
                    this.myprojectilegroup.fire(this.x, this.y, bulletLookVector, {
                        speed: this.shotSpeed,
                        damage: this.shotDamage,
                        maxPierce: this.shotPierce,
                        maxDistance: this.shotDistance,
                        width: 25,
                        height: 10,
                    })
                }
            }

            isAlive() {
                if (this.health <= 0) { return false }
                return true
            }

            updatePlayerMovement() {
                this.setAcceleration(0, 0)
                this.setAngularAcceleration(0)

                let playerMouseDelta = new Phaser.Math.Vector2(this.myscene.input.mousePointer.x - this.x, this.myscene.input.mousePointer.y - this.y)
                let playerLookVector = new Phaser.Math.Vector2(Math.cos(this.rotation), Math.sin(this.rotation))

                this.setRotation(Math.atan2(playerMouseDelta.y, playerMouseDelta.x))

                let movementVector = new Phaser.Math.Vector2(0, 0)

                if (keys.W.isDown) { movementVector.add(new Phaser.Math.Vector2(0, -1)) }
                if (keys.A.isDown) { movementVector.add(new Phaser.Math.Vector2(-1, 0)) }
                if (keys.S.isDown) { movementVector.add(new Phaser.Math.Vector2(0, 1)) }
                if (keys.D.isDown) { movementVector.add(new Phaser.Math.Vector2(1, 0)) }

                movementVector.normalize()

                this.setAcceleration(this.movementSpeed * movementVector.x, this.movementSpeed * movementVector.y)
            }

            preUpdate(time, deltaTime) {
                super.preUpdate(time, deltaTime)

                if (!this.isAlive()) {
                    this.destroy()
                    return
                }

                if (this._iframeremainingtime > 0) {
                    this._iframeremainingtime = Math.max(0, this._iframeremainingtime - deltaTime);
                }

                this._timesincelastshot += deltaTime
                if (this._timesincelastshot >= (1 / (this.fireRate / 60) * 1000) && this.myscene.input.mousePointer.isDown) {
                    this._timesincelastshot = 0;
                    this.shoot()
                }

                this.updatePlayerMovement()
            }

            takeDamage(damage) {
                if (this._iframeremainingtime > 0) {
                    return;
                }
                console.log("player took damage", damage)

                this._iframeremainingtime = this.iframeTime * 1000;
                this.health -= damage;
            }
        }

        class SwarmEnemy extends Phaser.Physics.Arcade.Sprite {
            _timesincelastmove = 0;
            _scene;

            target;
            health = 150;
            moveDelay = 1; //seconds
            attackDamage = 5;
            alive = true;

            UUID = ([1e7] + -1e3 + -4e3 + -8e3 + -1e11).replace(/[018]/g, c => (c ^ crypto.getRandomValues(new Uint8Array(1))[0] & 15 >> c / 4).toString(16));

            constructor(scene, x, y, projectileGroup) {
                super(scene, x, y, 'swarmEnemy');
                scene.add.existing(this);
                scene.physics.add.existing(this);
                this._scene = scene;
                this.setGravityY(0);
                this.setScale(.5);
                this.move(this);
                this.target = player;
                this.setMaxVelocity(150, 150);
            }

            setTarget(target) {
                this.target = target
            }

            isAlive() {
                if (this.health <= 0) { return false }
                return true
            }

            kill() {
                this.destroy();
                this.alive = false;
                console.log("Died")
            }

            reflectPosition() {
                if (this.x >= config.width + this.width) {
                    this.x = 1
                } else if (this.x <= 0 - this.width) {
                    this.x = config.width - 1;
                }

                if (this.y >= config.height + this.height) {
                    this.y = 1
                } else if (this.y <= 0 - this.height) {
                    this.y = config.height - 1;
                }
            }

            //moves the enemy to a random targeted location
            move() {
                let newspotx = Phaser.Math.Between(1, 1200);
                let newspoty = Phaser.Math.Between(1, 700);
                this.setAccelerationX((newspotx - this.x) / 3);
                this.setAccelerationY((newspoty - this.y) / 3);
            }

            preUpdate(time, deltaTime) {
                super.preUpdate(time, deltaTime)
                if (!this.isAlive()) { this.kill(); return; }

                this.rotation = Math.atan2(this.target.y - this.y, this.target.x - this.x);

                this._timesincelastmove += deltaTime;
                if (this._timesincelastmove >= this.moveDelay * 1000) {
                    this.move();
                    this._timesincelastmove = 0;
                }

                this.reflectPosition();
            }

            takeDamage(damage) {
                this.health -= damage;
            }
        }

        class ShooterEnemy extends Phaser.Physics.Arcade.Sprite {
            _timesincelastmove = 0;
            _shotdelaytime = 0;
            _scene;
            _projectileGroup;

            target;
            health = 150;
            moveDelay = 1; //seconds
            shotDelay = 3; //seconds
            shotEnvelope = 1.5 // randomize to min and max
            attackDamage = 0;
            alive = true;

            UUID = ([1e7] + -1e3 + -4e3 + -8e3 + -1e11).replace(/[018]/g, c => (c ^ crypto.getRandomValues(new Uint8Array(1))[0] & 15 >> c / 4).toString(16));

            constructor(scene, x, y, projectileGroup) {
                super(scene, x, y, 'shooterEnemy');
                scene.add.existing(this);
                scene.physics.add.existing(this);
                this._scene = scene;
                this._projectileGroup = projectileGroup

                this.setGravityY(0);
                this.setScale(.25);
                this.move(this);
                this.target = player;
                this.setMaxVelocity(150, 150);
            }

            setTarget(target) {
                this.target = target
            }

            isAlive() {
                if (this.health <= 0) { return false }
                return true
            }

            kill() {
                this.destroy();
                this.alive = false;
                console.log("Died")
            }

            reflectPosition() {
                if (this.x >= config.width + this.width) {
                    this.x = 1
                } else if (this.x <= 0 - this.width) {
                    this.x = config.width - 1;
                }

                if (this.y >= config.height + this.height) {
                    this.y = 1
                } else if (this.y <= 0 - this.height) {
                    this.y = config.height - 1;
                }
            }

            //moves the enemy to a random targeted location
            move() {
                let newspotx = Phaser.Math.Between(1, 1200);
                let newspoty = Phaser.Math.Between(1, 700);
                this.setAccelerationX((newspotx - this.x) / 3);
                this.setAccelerationY((newspoty - this.y) / 3);
            }

            shoot() {
                this._projectileGroup.fire(this.x, this.y, new Phaser.Math.Vector2(Math.cos(this.rotation), Math.sin(this.rotation)), {
                    speed: 500,
                    damage: 10,
                    maxPierce: 0,
                    maxDistance: 1000,
                    width: 10,
                    height: 10,
                })
            }

            preUpdate(time, deltaTime) {
                super.preUpdate(time, deltaTime)
                if (!this.isAlive()) { this.kill(); return; }

                this.rotation = Math.atan2(this.target.y - this.y, this.target.x - this.x);

                this._timesincelastmove += deltaTime;
                if (this._timesincelastmove >= this.moveDelay * 1000) {
                    this.move();
                    this._timesincelastmove = 0;
                }

                this._shotdelaytime = Math.max(0, this._shotdelaytime - deltaTime)
                if (this._shotdelaytime <= 0) {
                    this.shoot();
                    this._shotdelaytime = (this.shotDelay + Phaser.Math.FloatBetween(-this.shotEnvelope, this.shotEnvelope)) * 1000
                }

                this.reflectPosition();
            }

            takeDamage(damage) {
                this.health -= damage;
            }
        }

        class RunnerEnemy extends Phaser.Physics.Arcade.Sprite {
            _scene;

            health = 10;
            attackDamage = 10;
            alive = true;
            
            useWave = true;
            waveAmplitude = 0
            waveTimeScale = 0

            moveDirection;

            UUID = ([1e7] + -1e3 + -4e3 + -8e3 + -1e11).replace(/[018]/g, c => (c ^ crypto.getRandomValues(new Uint8Array(1))[0] & 15 >> c / 4).toString(16));

            constructor(scene, x, y, direction) {
                super(scene, x, y, 'runnerEnemy');
                scene.add.existing(this);
                scene.physics.add.existing(this);
                this._scene = scene;
                this.setGravityY(0);
                this.setScale(.1);
                this.target = player;
                
                this.moveDirection = direction.normalize().scale(Phaser.Math.Between(400, 600))
                this.waveAmplitude = Phaser.Math.Between(0, 300)
                this.waveTimeScale = Phaser.Math.Between(1, 5)

                this.setBodySize(50, 25, true)
                this.setDisplaySize(50, 25)
                this.width = 50
                this.height = 25
            }

            create() {
                console.log("created")

            }

            isAlive() {
                if (this.health <= 0) { return false }
                return true
            }

            kill() {
                this.destroy();
                this.alive = false;
                console.log("Died")
            }

            reflectPosition() {
                if (this.x >= config.width + this.width) {
                    this.x = 1
                } else if (this.x <= 0 - this.width) {
                    this.x = config.width - 1;
                }

                if (this.y >= config.height + this.height) {
                    this.y = 1
                } else if (this.y <= 0 - this.height) {
                    this.y = config.height - 1;
                }
            }

            preUpdate(time, deltaTime) {
                super.preUpdate(time, deltaTime)
                if (!this.isAlive()) { this.kill(); return; }

                this.rotation = Math.atan2(this.body.velocity.y, this.body.velocity.x);
                this.reflectPosition();

                if (this.useWave) {
                    let moveVector = this.moveDirection.clone()
                    let rightVector = this.moveDirection.clone().normalize().rotate(Math.PI /2).scale(this.waveAmplitude * Math.cos(this.waveTimeScale * time / 1000))

                    this.body.velocity = moveVector.add(rightVector)
                }
            }

            takeDamage(damage) {
                console.log(damage, "took damage")
                this.health -= damage;
            } 
        }

        var game = new Phaser.Game(config);
        var player;

        var playerProjectileGroup;
        var enemyProjectileGroup;

        //Keyboard controls
        var cursors;
        var keys;
        var space;

        var enemies = [];

        function preload() {
            this.load.image('stars', 'assets/images/newstarbackground.png');
            this.load.image('player', 'assets/images/maincharacter.png');
            
            this.load.image('swarmEnemy', 'assets/images/Enemy_1.png');
            this.load.image('shooterEnemy', 'assets/images/Imp.png')
            this.load.image('runnerEnemy', 'assets/images/Rocket.png')

            this.load.image('playerLaser', 'assets/images/PlayerLaser.png')
            this.load.image('enemyLaser', 'assets/images/EnemyLaser.png')

            this.load.audio('playershoot', 'assets/audio/playershoot_1.mp3')
        }

        // initializes a single Runner Enemy
        function createSwarmEnemy(tempScene) {
                let myEnemy = new RunnerEnemy(tempScene, 100, 100, new Phaser.Math.Vector2(1, 1));
                myEnemy.target = player;
                enemies.push(myEnemy);

            // let myShooter = new ShooterEnemy(tempScene, 100, 100, enemyProjectileGroup)
            // myShooter.target = player
            // enemies.push(myShooter)
        }

        //moves all sprites in enemies[]
        function create() {
            let background = this.add.tileSprite(0, 0, game.scale.width, game.scale.height, 'stars').setOrigin(0, 0);
            playerProjectileGroup = new ProjectileGroup(this, 'playerLaser');
            enemyProjectileGroup = new ProjectileGroup(this, 'enemyLaser');

            player = new Player(this, config.width / 2, config.height / 2, playerProjectileGroup);

            for (let i = 1; i <= 50; i++) {
                createSwarmEnemy(this)
            }

            //Set up user input
            cursors = this.input.keyboard.createCursorKeys();
            keys = this.input.keyboard.addKeys('W, A, S, D');
        }

        function update(time, delta) {
            let deltaSeconds = delta / 1000
            let timeSeconds = time / 1000

            this.physics.overlap(player, enemies, function (player, targetEnemy) { player.takeDamage(targetEnemy.attackDamage); });
            this.physics.overlap(enemies, playerProjectileGroup, function (enemy, playerProjectile) { enemy.takeDamage(playerProjectile.damage); playerProjectile.onHit(enemy); })
            this.physics.overlap(player, enemyProjectileGroup, function (player, enemyProjectile) { console.log(enemyProjectile.damage, player.health);  player.takeDamage(enemyProjectile.damage); enemyProjectile.onHit(player); })
        }
    </script>

</body>

</html>